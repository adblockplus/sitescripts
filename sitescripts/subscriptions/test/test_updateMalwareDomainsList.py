# This file is part of the Adblock Plus web scripts,
# Copyright (C) 2006-present eyeo GmbH
#
# Adblock Plus is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# Adblock Plus is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.

import io
import ConfigParser
import subprocess
import urllib2
import zipfile

import pytest

from sitescripts.subscriptions.bin.updateMalwareDomainsList import main

CONF_SECTION = 'subscriptionDownloads'


@pytest.fixture(autouse=True)
def md_repo(tmpdir):
    """A mock of our malware domains repo"""
    repo_dir = tmpdir.mkdir('md_repo')
    repo_dir.join('foo').write('foo')
    subprocess.check_call(['hg', 'init'], cwd=repo_dir.strpath)
    subprocess.check_call(['hg', 'commit', '-q', '-m', 'foo', '-A'],
                          cwd=repo_dir.strpath)
    return repo_dir


@pytest.fixture(autouse=True)
def config(mocker, md_repo):
    """A mock of sitescripts config"""
    config = ConfigParser.ConfigParser()
    config.add_section(CONF_SECTION)
    config.set(CONF_SECTION, 'malwaredomains_repository', md_repo.strpath)
    config.set(CONF_SECTION, 'malwaredomains_mirrors', 'good')
    module = 'sitescripts.subscriptions.bin.updateMalwareDomainsList'
    mocker.patch(module + '.get_config', lambda: config)
    return config


@pytest.fixture(autouse=True)
def urlopen(mocker):
    """Mock urlopen function"""
    real_urlopen = urllib2.urlopen

    def mock_urlopen(url):
        if url.startswith('good'):
            zf_data = io.BytesIO()
            with zipfile.ZipFile(zf_data, 'w') as zf:
                idna_urls = ['xn--xhq02ykwbp4a.cn', 'xn--fiq80yua78t.tw']
                zf.writestr('justdomains', '\n'.join(idna_urls) + '\n')
            return io.BytesIO(zf_data.getvalue())
        if url.startswith('bad'):
            raise urllib2.HTTPError('Bad', '42', 'No good', [], None)
        if url.startswith('ugly'):
            raise urllib2.URLError('Ugly')
        return real_urlopen(url)

    mocker.patch('urllib2.urlopen', mock_urlopen)


def test_good(md_repo):
    main()
    subprocess.check_call(['hg', 'up'], cwd=md_repo.strpath)
    result = md_repo.join('malwaredomains_full.txt').read()
    puny_urls = ['xn--xhq02ykwbp4a.cn', 'xn--fiq80yua78t.tw']
    for url in puny_urls:
        assert url in result


def test_bad(md_repo, config):
    config.set(CONF_SECTION, 'malwaredomains_mirrors', 'bad')
    try:
        main()
    except SystemExit as exc:
        err_lines = str(exc).splitlines()
        assert len(err_lines) == 3
        assert 'Failed to fetch bad/files/justdomains.zip' in err_lines[2]
        assert '42: No good' in err_lines[2]


def test_ugly(md_repo, config):
    config.set(CONF_SECTION, 'malwaredomains_mirrors', 'bad\nugly')
    try:
        main()
    except SystemExit as exc:
        err_lines = str(exc).splitlines()
        assert len(err_lines) == 4
        assert 'Failed to fetch bad/files/justdomains.zip' in err_lines[2]
        assert 'Failed to fetch ugly/files/justdomains.zip' in err_lines[3]
        assert 'Ugly' in err_lines[3]
